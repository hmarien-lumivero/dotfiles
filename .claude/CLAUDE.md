- NEVER stage changes or write commits
- Whenever you summarize what you have done, propose a one-liner commit message that reflects these changes.
- In all interactions and commit messages, be extremely consice and scraifice grammar for the sake of concision.
- Prefer pure functions, simple data objects and composition over classes and inheritence
- Write code that flows naturally and makes sense to humans first.
- Only add comments and function documentation if the code does not explain itself.
- Before you rework code, make sure automated tests for the happy path and obvious error paths are in place.

# Python-specific instructions

- Always add type hints to function definition in new code
    - For type hints always use symbols from typing package, no built-in types (e.g. use `List` from typing package instead of `list` type)
    - Use `Optional` from typing package instead of `XYZ | None` pattern
- Functions only used within a module shall be prefixed by underscore, e.g. `_my_internal_function()`

# Follow these instructions when you are tasked to develop new code or do a major refactoring

- Separate Integration from Operation: Design each function to have one type of responsibility – either orchestrating other functions or performing actual work, but not both. This means you should clearly separate code that coordinates tasks from code that executes the detailed logic of those tasks.
- Integration Functions (Orchestration): Use integration functions to coordinate the high-level workflow of your program. These functions should call only your own functions (other integrations or operations) and should not contain direct calculations or calls to external libraries within them. An integration function strings together operations (or other integrations) to implement business logic, without getting into the low-level details itself.
- Operation Functions (Work): Use operation functions to carry out the detailed, low-level tasks. An operation function contains the actual logic for a single task – such as computations, data transformations, or calling external APIs/framework functions. It does not call other custom functions in your code; by doing the work independently (possibly using standard library calls), it stays focused on one level of detail and has no internal dependencies on your own code.
- Never Mix the Two in One Function: Avoid mixing high-level orchestration with low-level logic inside the same function. If you find an integration function needs to perform a calculation or evaluate a complex condition, move that logic into a separate operation function. Keeping integration and operation code separate makes the high-level process clearer to understand, since the overall steps aren’t obscured by details.
- Refactor to Separate Concerns: When working with existing code, look for any large or confusing functions that are doing both coordination and computation at once. Split those functions into smaller ones, and classify each new function as either integration or operation. If you’re unsure which category a function falls into, that’s a sign it should be broken down further until each function’s role is obvious.
- Keep Logic Out of Integration Control Flow: It’s fine to use basic control structures (if/for/while) in an integration function to direct the flow, but keep any logic out of these structures. For example, don’t write a complex condition directly in an if statement – instead call a tiny operation function that returns the condition result (e.g. IsValid(x)). Similarly, a loop in an integration should just iterate and call an operation for the work inside, rather than containing calculation code itself. This keeps integration code clean and each piece of logic testable on its own.
- One Function, One Level of Detail: Ensure that each function operates at a single level of abstraction (detail). Integration functions work at a high level (just calling other functions with no inner logic), while operation functions work at a low level (handling all the detail of one task with no awareness of the bigger workflow). This single-level focus makes functions easier to read and maintain, because you’re never mixing high-level and low-level code together in one place.
- Small and Focused Functions: Aim to make both integration and operation functions small and focused on one purpose. Each function should do one thing and do it well, which naturally follows the Single Responsibility Principle (each function has one reason to change). This makes it easier to give functions meaningful names and helps others (or your future self) quickly understand what each piece of code does.
- Simpler Testing: Write tests according to this division of responsibilities. Integration functions contain no complex logic, so you only need a few tests to verify that they call the right operations in the right order. Operation functions are independent units of logic, which you can cover with focused unit tests – these are easy to write because operations don’t rely on other custom code, often eliminating the need for complicated mocks.
- Use Plain Functions and Data Structures: You can apply the Integration-Operation separation in any programming paradigm. In languages like Python or C#, you don’t need special classes or patterns – just define ordinary functions to serve as integrations or operations. Use simple data objects (e.g. dictionaries, lists, or basic classes/records) to pass information. The key is how you organize function calls: let integration functions handle the sequence of steps, while operation functions handle the actual processing of data.
- Never ever use "Integration" or "Operation" in function documentation or encoded in function names. These terms may confuse the reader.